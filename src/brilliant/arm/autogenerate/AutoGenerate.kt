package brilliant.arm.autogenerate

import java.io.BufferedReader
import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.io.InputStreamReader
import java.io.PrintWriter
import java.util.ArrayList

object AutoGenerate {

    val THUMB16_PATH = "src/brilliant/arm/OpCode/thumb/instruction16/"
    val THUMB16_CFG = "src/brilliant/arm/autogenerate/Thumb16Instruction.cfg"

    val THUMB32_PATH = "src/brilliant/arm/OpCode/thumb/instruction32/"
    val THUMB32_CFG = "src/brilliant/arm/autogenerate/Thumb32Instruction.cfg"

    val ARM_PATH = "src/brilliant/arm/OpCode/arm/instruction/"
    val ARM_CFG = "src/brilliant/arm/autogenerate/ArmInstruction.cfg"

    @JvmStatic fun main(args: Array<String>) {
        try {
            generateThumb16Class()
            generateThumb32Class()
            generateArmClass()
        } catch (e: Exception) {
            e.printStackTrace()
        }

    }

    @Throws(Exception::class)
    private fun generateArmClass() {

        val ARM_CLASS_NAME = parseNeededClass(ARM_CFG)

        for (fileName in ARM_CLASS_NAME!!) {
            var fileName2Put = fileName
            val file: File
            if (fileName.endsWith("*")) {
                fileName2Put = fileName.substring(0, fileName.length - 1)

                file = File(ARM_PATH + fileName2Put + ".java")
                if (!file.exists())
                    generateNewFileArm(file, fileName2Put, true)
                else
                    System.err.println(fileName2Put + " exist , skipping")
            } else {
                file = File(ARM_PATH + fileName2Put + ".java")
                if (!file.exists())
                    generateNewFileArm(file, fileName2Put, false)
                else
                    System.err.println(fileName2Put + " exist , skipping")
            }
        }
    }

    @Throws(Exception::class)
    private fun generateThumb16Class() {

        val THUMB16_CLASS_NAME = parseNeededClass(THUMB16_CFG)

        for (fileName in THUMB16_CLASS_NAME!!) {
            var fileName2Put = fileName
            val file: File
            if (fileName.endsWith("*")) {
                fileName2Put = fileName.substring(0, fileName.length - 1)
                file = File(THUMB16_PATH + fileName2Put + ".java")
                if (!file.exists())
                    generateNewFileThumb16(file, fileName2Put, true)
                else
                    System.err.println(fileName2Put + " exist , skipping")
            } else {

                file = File(THUMB16_PATH + fileName2Put + ".java")
                if (!file.exists())
                    generateNewFileThumb16(file, fileName2Put, false)
                else
                    System.err.println(fileName2Put + " exist , skipping")
            }
        }
    }

    @Throws(Exception::class)
    private fun generateThumb32Class() {

        val THUMB32_CLASS_NAME = parseNeededClass(THUMB32_CFG)

        for (fileName in THUMB32_CLASS_NAME!!) {

            var fileName2Put = fileName

            val file: File
            if (fileName.endsWith("*")) {
                fileName2Put = fileName.substring(0, fileName.length - 1)

                file = File(THUMB32_PATH + fileName2Put + ".java")
                if (!file.exists())
                    generateNewFileThumb32(file, fileName2Put, true)
                else
                    System.err.println(fileName2Put + " exist , skipping")
            } else {

                file = File(THUMB32_PATH + fileName2Put + ".java")
                if (!file.exists())
                    generateNewFileThumb32(file, fileName2Put, false)
                else
                    System.err.println(fileName2Put + " exist , skipping")
            }
        }
    }

    @Throws(Exception::class)
    private fun parseNeededClass(cfg: String): List<String> {

        val file = File(cfg)
        val clz = ArrayList<String>()
        if (file.exists()) {
            val br = BufferedReader(InputStreamReader(
                    FileInputStream(file)))

            var className: String?
 BreakPoint@
            while (true) {
                className = br.readLine();
                if(className == null)
                    break@BreakPoint;
                if ("" != className && !className.startsWith("#"))
                    clz.add(className)
            }
            br.close()
        }
        return clz
    }

    private fun generateNewFileArm(file: File, className: String?,
                                   no_implements: Boolean) {

        try {
            file.createNewFile()

            val pw = PrintWriter(file)
            pw.println("/*-------------------------------")
            pw.println(" Auto Generated By AutoGenetate.java")
            pw.println("     Don't remove or modify")
            pw.println("        License GPL/GNU")
            pw.println("-------------------------------*/")

            pw.println("package brilliant.arm.OpCode.arm.instruction;")
            pw.println()
            pw.println("import brilliant.arm.OpCode.arm.instruction.support.ParseSupport;")

            if (!no_implements) {
                pw.println("import static brilliant.elf.vm.OS.*;")
                pw.println("import static brilliant.elf.vm.Register.*;")
                pw.println("import static brilliant.arm.OpCode.OpUtil.*;")
            }

            pw.println()

            if (no_implements)
                pw.println("@Deprecated")

            pw.println("public class $className extends ParseSupport {")
            pw.println()
            pw.println("	public static final " + className + " INSTANCE = new "
                    + className + "();")
            pw.println()

            pw.println("	@Override")
            pw.println("	protected String getOpCode(int data) {")
            pw.println("		return \"" + className!!.split("_".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()[0] + "\";")
            pw.println("	}")

            if (!no_implements) {

                pw.println("	@Override")
                pw.println("	protected int getRd(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getRn(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getRm(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getS(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getType(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getShift(int data) {")
                pw.println("		return 0;")
                pw.println("	}")

            }

            pw.println("	@Override")
            pw.println("	public void performExecuteCommand(int data) {")
            pw.println("	}")

            pw.println()
            pw.print("}")

            pw.flush()
            pw.close()

            println(className + " generated successfully")
        } catch (e: IOException) {
            throw RuntimeException(e)
        }

    }

    private fun generateNewFileThumb16(file: File, className: String?,
                                       no_implements: Boolean) {

        try {
            file.createNewFile()

            val pw = PrintWriter(file)
            pw.println("/*-------------------------------")
            pw.println(" Auto Generated By AutoGenetate.java")
            pw.println("     Don't remove or modify")
            pw.println("        License GPL/GNU")
            pw.println("-------------------------------*/")

            pw.println("package brilliant.arm.OpCode.thumb.instruction16;")
            pw.println()
            pw.println("import brilliant.arm.OpCode.thumb.instruction16.support.ParseSupport;")

            if (!no_implements) {
                pw.println("import static brilliant.elf.vm.OS.*;")
                pw.println("import static brilliant.vm.Register.*;")
                pw.println("import static brilliant.elf.arm.OpCode.OpUtil.*;")
            }
            pw.println()

            if (no_implements)
                pw.println("@Deprecated")

            pw.println("public class $className extends ParseSupport {")
            pw.println()
            pw.println("	public static final " + className + " INSTANCE = new "
                    + className + "();")
            pw.println()

            pw.println("	@Override")
            pw.println("	protected String getOpCode(int data) {")
            pw.println("		return \"" + className!!.split("_".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()[0] + "\";")
            pw.println("	}")

            if (!no_implements) {

                pw.println("	@Override")
                pw.println("	protected String getRn(int data) {")
                pw.println("		return null;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected String getRm(int data) {")
                pw.println("		return null;")
                pw.println("	}")
            }

            pw.println("	@Override")
            pw.println("	public void performExecuteCommand(int data) {")
            pw.println("	}")

            pw.println()
            pw.print("}")

            pw.flush()
            pw.close()

            println(className + " generated successfully")
        } catch (e: IOException) {
            throw RuntimeException(e)
        }

    }

    private fun generateNewFileThumb32(file: File, className: String?,
                                       no_implements: Boolean) {

        try {
            file.createNewFile()

            val pw = PrintWriter(file)
            pw.println("/*-------------------------------")
            pw.println(" Auto Generated By AutoGenetate.java")
            pw.println("     Don't remove or modify")
            pw.println("        License GPL/GNU")
            pw.println("-------------------------------*/")

            pw.println("package brilliant.arm.OpCode.thumb.instruction32;")
            pw.println()
            pw.println("import brilliant.arm.OpCode.thumb.instruction32.support.ParseSupport;")

            if (!no_implements) {
                pw.println("import static brilliant.elf.vm.OS.*;")
                pw.println("import static brilliant.elf.vm.Register.*;")
                pw.println("import static brilliant.arm.OpCode.OpUtil.*;")
            }
            pw.println()

            if (no_implements)
                pw.println("@Deprecated")

            pw.println("public class $className extends ParseSupport {")
            pw.println()
            pw.println("	public static final " + className + " INSTANCE = new "
                    + className + "();")
            pw.println()

            pw.println("	@Override")
            pw.println("	protected String getOpCode(int data) {")
            pw.println("		return \"" + className!!.split("_".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()[0] + "\";")
            pw.println("	}")

            if (!no_implements) {

                pw.println("	@Override")
                pw.println("	protected int getRd(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getRn(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getRm(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getS(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getType(int data) {")
                pw.println("		return -1;")
                pw.println("	}")
                pw.println("	@Override")
                pw.println("	protected int getShift(int data) {")
                pw.println("		return 0;")
                pw.println("	}")

            }

            pw.println("	@Override")
            pw.println("	public void performExecuteCommand(int data) {")
            pw.println("	}")

            pw.println()
            pw.print("}")

            pw.flush()
            pw.close()

            println(className + " generated successfully")
        } catch (e: IOException) {
            throw RuntimeException(e)
        }

    }
}
